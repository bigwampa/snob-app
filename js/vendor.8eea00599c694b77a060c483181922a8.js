/*!
* YieldFarming
* Boilerplate for a Static website using EJS and SASS
* https://yieldfarming.info
* @author Jongseung Lim -- https://yieldfarming.info
* Copyright 2021. MIT Licensed.
*/

!function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)t.d(r,i,function(n){return e[n]}.bind(null,i));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="/js/",t(t.s=376)}({204:function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/*! picturefill - v3.0.2 - 2016-02-12\n * https://scottjehl.github.io/picturefill/\n * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT\n */\n\n/*! Gecko-Picture - v1.0\n * https://github.com/scottjehl/picturefill/tree/3.0/src/plugins/gecko-picture\n * Firefox\'s early picture implementation (prior to FF41) is static and does\n * not react to viewport changes. This tiny module fixes this.\n */\n(function (window) {\n  /*jshint eqnull:true */\n  var ua = navigator.userAgent;\n\n  if (window.HTMLPictureElement && /ecko/.test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 < 45) {\n    addEventListener("resize", function () {\n      var timer;\n      var dummySrc = document.createElement("source");\n\n      var fixRespimg = function fixRespimg(img) {\n        var source, sizes;\n        var picture = img.parentNode;\n\n        if (picture.nodeName.toUpperCase() === "PICTURE") {\n          source = dummySrc.cloneNode();\n          picture.insertBefore(source, picture.firstElementChild);\n          setTimeout(function () {\n            picture.removeChild(source);\n          });\n        } else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {\n          img._pfLastSize = img.offsetWidth;\n          sizes = img.sizes;\n          img.sizes += ",100vw";\n          setTimeout(function () {\n            img.sizes = sizes;\n          });\n        }\n      };\n\n      var findPictureImgs = function findPictureImgs() {\n        var i;\n        var imgs = document.querySelectorAll("picture > img, img[srcset][sizes]");\n\n        for (i = 0; i < imgs.length; i++) {\n          fixRespimg(imgs[i]);\n        }\n      };\n\n      var onResize = function onResize() {\n        clearTimeout(timer);\n        timer = setTimeout(findPictureImgs, 99);\n      };\n\n      var mq = window.matchMedia && matchMedia("(orientation: landscape)");\n\n      var init = function init() {\n        onResize();\n\n        if (mq && mq.addListener) {\n          mq.addListener(onResize);\n        }\n      };\n\n      dummySrc.srcset = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n\n      if (/^[c|i]|d$/.test(document.readyState || "")) {\n        init();\n      } else {\n        document.addEventListener("DOMContentLoaded", init);\n      }\n\n      return onResize;\n    }());\n  }\n})(window);\n/*! Picturefill - v3.0.2\n * http://scottjehl.github.io/picturefill\n * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt;\n *  License: MIT\n */\n\n\n(function (window, document, undefined) {\n  // Enable strict mode\n  "use strict"; // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)\n\n  document.createElement("picture");\n  var warn, eminpx, alwaysCheckWDescriptor, evalId; // local object for method references and testing exposure\n\n  var pf = {};\n  var isSupportTestReady = false;\n\n  var noop = function noop() {};\n\n  var image = document.createElement("img");\n  var getImgAttr = image.getAttribute;\n  var setImgAttr = image.setAttribute;\n  var removeImgAttr = image.removeAttribute;\n  var docElem = document.documentElement;\n  var types = {};\n  var cfg = {\n    //resource selection:\n    algorithm: ""\n  };\n  var srcAttr = "data-pfsrc";\n  var srcsetAttr = srcAttr + "set"; // ua sniffing is done for undetectable img loading features,\n  // to do some non crucial perf optimizations\n\n  var ua = navigator.userAgent;\n  var supportAbort = /rident/.test(ua) || /ecko/.test(ua) && ua.match(/rv\\:(\\d+)/) && RegExp.$1 > 35;\n  var curSrcProp = "currentSrc";\n  var regWDesc = /\\s+\\+?\\d+(e\\d+)?w/;\n  var regSize = /(\\([^)]+\\))?\\s*(.+)/;\n  var setOptions = window.picturefillCFG;\n  /**\n   * Shortcut property for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )\n   */\n  // baseStyle also used by getEmValue (i.e.: width: 1em is important)\n\n  var baseStyle = "position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)";\n  var fsCss = "font-size:100%!important;";\n  var isVwDirty = true;\n  var cssCache = {};\n  var sizeLengthCache = {};\n  var DPR = window.devicePixelRatio;\n  var units = {\n    px: 1,\n    "in": 96\n  };\n  var anchor = document.createElement("a");\n  /**\n   * alreadyRun flag used for setOptions. is it true setOptions will reevaluate\n   * @type {boolean}\n   */\n\n  var alreadyRun = false; // Reusable, non-"g" Regexes\n  // (Don\'t use \\s, to avoid matching non-breaking space.)\n\n  var regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/,\n      regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/,\n      regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/,\n      regexTrailingCommas = /[,]+$/,\n      regexNonNegativeInteger = /^\\d+$/,\n      // ( Positive or negative or unsigned integers or decimals, without or without exponents.\n  // Must include at least one digit.\n  // According to spec tests any decimal point must be followed by a digit.\n  // No leading plus sign is allowed.)\n  // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number\n  regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;\n\n  var on = function on(obj, evt, fn, capture) {\n    if (obj.addEventListener) {\n      obj.addEventListener(evt, fn, capture || false);\n    } else if (obj.attachEvent) {\n      obj.attachEvent("on" + evt, fn);\n    }\n  };\n  /**\n   * simple memoize function:\n   */\n\n\n  var memoize = function memoize(fn) {\n    var cache = {};\n    return function (input) {\n      if (!(input in cache)) {\n        cache[input] = fn(input);\n      }\n\n      return cache[input];\n    };\n  }; // UTILITY FUNCTIONS\n  // Manual is faster than RegEx\n  // http://jsperf.com/whitespace-character/5\n\n\n  function isSpace(c) {\n    return c === " " || // space\n    c === "\\t" || // horizontal tab\n    c === "\\n" || // new line\n    c === "\\f" || // form feed\n    c === "\\r"; // carriage return\n  }\n  /**\n   * gets a mediaquery and returns a boolean or gets a css length and returns a number\n   * @param css mediaqueries or css length\n   * @returns {boolean|number}\n   *\n   * based on: https://gist.github.com/jonathantneal/db4f77009b155f083738\n   */\n\n\n  var evalCSS = function () {\n    var regLength = /^([\\d\\.]+)(em|vw|px)$/;\n\n    var replace = function replace() {\n      var args = arguments,\n          index = 0,\n          string = args[0];\n\n      while (++index in args) {\n        string = string.replace(args[index], args[++index]);\n      }\n\n      return string;\n    };\n\n    var buildStr = memoize(function (css) {\n      return "return " + replace((css || "").toLowerCase(), // interpret `and`\n      /\\band\\b/g, "&&", // interpret `,`\n      /,/g, "||", // interpret `min-` as >=\n      /min-([a-z-\\s]+):/g, "e.$1>=", // interpret `max-` as <=\n      /max-([a-z-\\s]+):/g, "e.$1<=", //calc value\n      /calc([^)]+)/g, "($1)", // interpret css values\n      /(\\d+[\\.]*[\\d]*)([a-z]+)/g, "($1 * e.$2)", //make eval less evil\n      /^(?!(e.[a-z]|[0-9\\.&=|><\\+\\-\\*\\(\\)\\/])).*/ig, "") + ";";\n    });\n    return function (css, length) {\n      var parsedLength;\n\n      if (!(css in cssCache)) {\n        cssCache[css] = false;\n\n        if (length && (parsedLength = css.match(regLength))) {\n          cssCache[css] = parsedLength[1] * units[parsedLength[2]];\n        } else {\n          /*jshint evil:true */\n          try {\n            cssCache[css] = new Function("e", buildStr(css))(units);\n          } catch (e) {}\n          /*jshint evil:false */\n\n        }\n      }\n\n      return cssCache[css];\n    };\n  }();\n\n  var setResolution = function setResolution(candidate, sizesattr) {\n    if (candidate.w) {\n      // h = means height: || descriptor.type === \'h\' do not handle yet...\n      candidate.cWidth = pf.calcListLength(sizesattr || "100vw");\n      candidate.res = candidate.w / candidate.cWidth;\n    } else {\n      candidate.res = candidate.d;\n    }\n\n    return candidate;\n  };\n  /**\n   *\n   * @param opt\n   */\n\n\n  var picturefill = function picturefill(opt) {\n    if (!isSupportTestReady) {\n      return;\n    }\n\n    var elements, i, plen;\n    var options = opt || {};\n\n    if (options.elements && options.elements.nodeType === 1) {\n      if (options.elements.nodeName.toUpperCase() === "IMG") {\n        options.elements = [options.elements];\n      } else {\n        options.context = options.elements;\n        options.elements = null;\n      }\n    }\n\n    elements = options.elements || pf.qsa(options.context || document, options.reevaluate || options.reselect ? pf.sel : pf.selShort);\n\n    if (plen = elements.length) {\n      pf.setupRun(options);\n      alreadyRun = true; // Loop through all elements\n\n      for (i = 0; i < plen; i++) {\n        pf.fillImg(elements[i], options);\n      }\n\n      pf.teardownRun(options);\n    }\n  };\n  /**\n   * outputs a warning for the developer\n   * @param {message}\n   * @type {Function}\n   */\n\n\n  warn = window.console && console.warn ? function (message) {\n    console.warn(message);\n  } : noop;\n\n  if (!(curSrcProp in image)) {\n    curSrcProp = "src";\n  } // Add support for standard mime types.\n\n\n  types["image/jpeg"] = true;\n  types["image/gif"] = true;\n  types["image/png"] = true;\n\n  function detectTypeSupport(type, typeUri) {\n    // based on Modernizr\'s lossless img-webp test\n    // note: asynchronous\n    var image = new window.Image();\n\n    image.onerror = function () {\n      types[type] = false;\n      picturefill();\n    };\n\n    image.onload = function () {\n      types[type] = image.width === 1;\n      picturefill();\n    };\n\n    image.src = typeUri;\n    return "pending";\n  } // test svg support\n\n\n  types["image/svg+xml"] = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");\n  /**\n   * updates the internal vW property with the current viewport width in px\n   */\n\n  function updateMetrics() {\n    isVwDirty = false;\n    DPR = window.devicePixelRatio;\n    cssCache = {};\n    sizeLengthCache = {};\n    pf.DPR = DPR || 1;\n    units.width = Math.max(window.innerWidth || 0, docElem.clientWidth);\n    units.height = Math.max(window.innerHeight || 0, docElem.clientHeight);\n    units.vw = units.width / 100;\n    units.vh = units.height / 100;\n    evalId = [units.height, units.width, DPR].join("-");\n    units.em = pf.getEmValue();\n    units.rem = units.em;\n  }\n\n  function chooseLowRes(lowerValue, higherValue, dprValue, isCached) {\n    var bonusFactor, tooMuch, bonus, meanDensity; //experimental\n\n    if (cfg.algorithm === "saveData") {\n      if (lowerValue > 2.7) {\n        meanDensity = dprValue + 1;\n      } else {\n        tooMuch = higherValue - dprValue;\n        bonusFactor = Math.pow(lowerValue - 0.6, 1.5);\n        bonus = tooMuch * bonusFactor;\n\n        if (isCached) {\n          bonus += 0.1 * bonusFactor;\n        }\n\n        meanDensity = lowerValue + bonus;\n      }\n    } else {\n      meanDensity = dprValue > 1 ? Math.sqrt(lowerValue * higherValue) : lowerValue;\n    }\n\n    return meanDensity > dprValue;\n  }\n\n  function applyBestCandidate(img) {\n    var srcSetCandidates;\n    var matchingSet = pf.getSet(img);\n    var evaluated = false;\n\n    if (matchingSet !== "pending") {\n      evaluated = evalId;\n\n      if (matchingSet) {\n        srcSetCandidates = pf.setRes(matchingSet);\n        pf.applySetCandidate(srcSetCandidates, img);\n      }\n    }\n\n    img[pf.ns].evaled = evaluated;\n  }\n\n  function ascendingSort(a, b) {\n    return a.res - b.res;\n  }\n\n  function setSrcToCur(img, src, set) {\n    var candidate;\n\n    if (!set && src) {\n      set = img[pf.ns].sets;\n      set = set && set[set.length - 1];\n    }\n\n    candidate = getCandidateForSrc(src, set);\n\n    if (candidate) {\n      src = pf.makeUrl(src);\n      img[pf.ns].curSrc = src;\n      img[pf.ns].curCan = candidate;\n\n      if (!candidate.res) {\n        setResolution(candidate, candidate.set.sizes);\n      }\n    }\n\n    return candidate;\n  }\n\n  function getCandidateForSrc(src, set) {\n    var i, candidate, candidates;\n\n    if (src && set) {\n      candidates = pf.parseSet(set);\n      src = pf.makeUrl(src);\n\n      for (i = 0; i < candidates.length; i++) {\n        if (src === pf.makeUrl(candidates[i].url)) {\n          candidate = candidates[i];\n          break;\n        }\n      }\n    }\n\n    return candidate;\n  }\n\n  function getAllSourceElements(picture, candidates) {\n    var i, len, source, srcset; // SPEC mismatch intended for size and perf:\n    // actually only source elements preceding the img should be used\n    // also note: don\'t use qsa here, because IE8 sometimes doesn\'t like source as the key part in a selector\n\n    var sources = picture.getElementsByTagName("source");\n\n    for (i = 0, len = sources.length; i < len; i++) {\n      source = sources[i];\n      source[pf.ns] = true;\n      srcset = source.getAttribute("srcset"); // if source does not have a srcset attribute, skip\n\n      if (srcset) {\n        candidates.push({\n          srcset: srcset,\n          media: source.getAttribute("media"),\n          type: source.getAttribute("type"),\n          sizes: source.getAttribute("sizes")\n        });\n      }\n    }\n  }\n  /**\n   * Srcset Parser\n   * By Alex Bell |  MIT License\n   *\n   * @returns Array [{url: _, d: _, w: _, h:_, set:_(????)}, ...]\n   *\n   * Based super duper closely on the reference algorithm at:\n   * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n   */\n  // 1. Let input be the value passed to this algorithm.\n  // (TO-DO : Explain what "set" argument is here. Maybe choose a more\n  // descriptive & more searchable name.  Since passing the "set" in really has\n  // nothing to do with parsing proper, I would prefer this assignment eventually\n  // go in an external fn.)\n\n\n  function parseSrcset(input, set) {\n    function collectCharacters(regEx) {\n      var chars,\n          match = regEx.exec(input.substring(pos));\n\n      if (match) {\n        chars = match[0];\n        pos += chars.length;\n        return chars;\n      }\n    }\n\n    var inputLength = input.length,\n        url,\n        descriptors,\n        currentDescriptor,\n        state,\n        c,\n        // 2. Let position be a pointer into input, initially pointing at the start\n    //    of the string.\n    pos = 0,\n        // 3. Let candidates be an initially empty source set.\n    candidates = [];\n    /**\n    * Adds descriptor properties to a candidate, pushes to the candidates array\n    * @return undefined\n    */\n    // (Declared outside of the while loop so that it\'s only created once.\n    // (This fn is defined before it is used, in order to pass JSHINT.\n    // Unfortunately this breaks the sequencing of the spec comments. :/ )\n\n    function parseDescriptors() {\n      // 9. Descriptor parser: Let error be no.\n      var pError = false,\n          // 10. Let width be absent.\n      // 11. Let density be absent.\n      // 12. Let future-compat-h be absent. (We\'re implementing it now as h)\n      w,\n          d,\n          h,\n          i,\n          candidate = {},\n          desc,\n          lastChar,\n          value,\n          intVal,\n          floatVal; // 13. For each descriptor in descriptors, run the appropriate set of steps\n      // from the following list:\n\n      for (i = 0; i < descriptors.length; i++) {\n        desc = descriptors[i];\n        lastChar = desc[desc.length - 1];\n        value = desc.substring(0, desc.length - 1);\n        intVal = parseInt(value, 10);\n        floatVal = parseFloat(value); // If the descriptor consists of a valid non-negative integer followed by\n        // a U+0077 LATIN SMALL LETTER W character\n\n        if (regexNonNegativeInteger.test(value) && lastChar === "w") {\n          // If width and density are not both absent, then let error be yes.\n          if (w || d) {\n            pError = true;\n          } // Apply the rules for parsing non-negative integers to the descriptor.\n          // If the result is zero, let error be yes.\n          // Otherwise, let width be the result.\n\n\n          if (intVal === 0) {\n            pError = true;\n          } else {\n            w = intVal;\n          } // If the descriptor consists of a valid floating-point number followed by\n          // a U+0078 LATIN SMALL LETTER X character\n\n        } else if (regexFloatingPoint.test(value) && lastChar === "x") {\n          // If width, density and future-compat-h are not all absent, then let error\n          // be yes.\n          if (w || d || h) {\n            pError = true;\n          } // Apply the rules for parsing floating-point number values to the descriptor.\n          // If the result is less than zero, let error be yes. Otherwise, let density\n          // be the result.\n\n\n          if (floatVal < 0) {\n            pError = true;\n          } else {\n            d = floatVal;\n          } // If the descriptor consists of a valid non-negative integer followed by\n          // a U+0068 LATIN SMALL LETTER H character\n\n        } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {\n          // If height and density are not both absent, then let error be yes.\n          if (h || d) {\n            pError = true;\n          } // Apply the rules for parsing non-negative integers to the descriptor.\n          // If the result is zero, let error be yes. Otherwise, let future-compat-h\n          // be the result.\n\n\n          if (intVal === 0) {\n            pError = true;\n          } else {\n            h = intVal;\n          } // Anything else, Let error be yes.\n\n        } else {\n          pError = true;\n        }\n      } // (close step 13 for loop)\n      // 15. If error is still no, then append a new image source to candidates whose\n      // URL is url, associated with a width width if not absent and a pixel\n      // density density if not absent. Otherwise, there is a parse error.\n\n\n      if (!pError) {\n        candidate.url = url;\n\n        if (w) {\n          candidate.w = w;\n        }\n\n        if (d) {\n          candidate.d = d;\n        }\n\n        if (h) {\n          candidate.h = h;\n        }\n\n        if (!h && !d && !w) {\n          candidate.d = 1;\n        }\n\n        if (candidate.d === 1) {\n          set.has1x = true;\n        }\n\n        candidate.set = set;\n        candidates.push(candidate);\n      }\n    } // (close parseDescriptors fn)\n\n    /**\n    * Tokenizes descriptor properties prior to parsing\n    * Returns undefined.\n    * (Again, this fn is defined before it is used, in order to pass JSHINT.\n    * Unfortunately this breaks the logical sequencing of the spec comments. :/ )\n    */\n\n\n    function tokenize() {\n      // 8.1. Descriptor tokeniser: Skip whitespace\n      collectCharacters(regexLeadingSpaces); // 8.2. Let current descriptor be the empty string.\n\n      currentDescriptor = ""; // 8.3. Let state be in descriptor.\n\n      state = "in descriptor";\n\n      while (true) {\n        // 8.4. Let c be the character at position.\n        c = input.charAt(pos); //  Do the following depending on the value of state.\n        //  For the purpose of this step, "EOF" is a special character representing\n        //  that position is past the end of input.\n        // In descriptor\n\n        if (state === "in descriptor") {\n          // Do the following, depending on the value of c:\n          // Space character\n          // If current descriptor is not empty, append current descriptor to\n          // descriptors and let current descriptor be the empty string.\n          // Set state to after descriptor.\n          if (isSpace(c)) {\n            if (currentDescriptor) {\n              descriptors.push(currentDescriptor);\n              currentDescriptor = "";\n              state = "after descriptor";\n            } // U+002C COMMA (,)\n            // Advance position to the next character in input. If current descriptor\n            // is not empty, append current descriptor to descriptors. Jump to the step\n            // labeled descriptor parser.\n\n          } else if (c === ",") {\n            pos += 1;\n\n            if (currentDescriptor) {\n              descriptors.push(currentDescriptor);\n            }\n\n            parseDescriptors();\n            return; // U+0028 LEFT PARENTHESIS (()\n            // Append c to current descriptor. Set state to in parens.\n          } else if (c === "(") {\n            currentDescriptor = currentDescriptor + c;\n            state = "in parens"; // EOF\n            // If current descriptor is not empty, append current descriptor to\n            // descriptors. Jump to the step labeled descriptor parser.\n          } else if (c === "") {\n            if (currentDescriptor) {\n              descriptors.push(currentDescriptor);\n            }\n\n            parseDescriptors();\n            return; // Anything else\n            // Append c to current descriptor.\n          } else {\n            currentDescriptor = currentDescriptor + c;\n          } // (end "in descriptor"\n          // In parens\n\n        } else if (state === "in parens") {\n          // U+0029 RIGHT PARENTHESIS ())\n          // Append c to current descriptor. Set state to in descriptor.\n          if (c === ")") {\n            currentDescriptor = currentDescriptor + c;\n            state = "in descriptor"; // EOF\n            // Append current descriptor to descriptors. Jump to the step labeled\n            // descriptor parser.\n          } else if (c === "") {\n            descriptors.push(currentDescriptor);\n            parseDescriptors();\n            return; // Anything else\n            // Append c to current descriptor.\n          } else {\n            currentDescriptor = currentDescriptor + c;\n          } // After descriptor\n\n        } else if (state === "after descriptor") {\n          // Do the following, depending on the value of c:\n          // Space character: Stay in this state.\n          if (isSpace(c)) {// EOF: Jump to the step labeled descriptor parser.\n          } else if (c === "") {\n            parseDescriptors();\n            return; // Anything else\n            // Set state to in descriptor. Set position to the previous character in input.\n          } else {\n            state = "in descriptor";\n            pos -= 1;\n          }\n        } // Advance position to the next character in input.\n\n\n        pos += 1; // Repeat this step.\n      } // (close while true loop)\n\n    } // 4. Splitting loop: Collect a sequence of characters that are space\n    //    characters or U+002C COMMA characters. If any U+002C COMMA characters\n    //    were collected, that is a parse error.\n\n\n    while (true) {\n      collectCharacters(regexLeadingCommasOrSpaces); // 5. If position is past the end of input, return candidates and abort these steps.\n\n      if (pos >= inputLength) {\n        return candidates; // (we\'re done, this is the sole return path)\n      } // 6. Collect a sequence of characters that are not space characters,\n      //    and let that be url.\n\n\n      url = collectCharacters(regexLeadingNotSpaces); // 7. Let descriptors be a new empty list.\n\n      descriptors = []; // 8. If url ends with a U+002C COMMA character (,), follow these substeps:\n      //\t\t(1). Remove all trailing U+002C COMMA characters from url. If this removed\n      //         more than one character, that is a parse error.\n\n      if (url.slice(-1) === ",") {\n        url = url.replace(regexTrailingCommas, ""); // (Jump ahead to step 9 to skip tokenization and just push the candidate).\n\n        parseDescriptors(); //\tOtherwise, follow these substeps:\n      } else {\n        tokenize();\n      } // (close else of step 8)\n      // 16. Return to the step labeled splitting loop.\n\n    } // (Close of big while loop.)\n\n  }\n  /*\n   * Sizes Parser\n   *\n   * By Alex Bell |  MIT License\n   *\n   * Non-strict but accurate and lightweight JS Parser for the string value <img sizes="here">\n   *\n   * Reference algorithm at:\n   * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-sizes-attribute\n   *\n   * Most comments are copied in directly from the spec\n   * (except for comments in parens).\n   *\n   * Grammar is:\n   * <source-size-list> = <source-size># [ , <source-size-value> ]? | <source-size-value>\n   * <source-size> = <media-condition> <source-size-value>\n   * <source-size-value> = <length>\n   * http://www.w3.org/html/wg/drafts/html/master/embedded-content.html#attr-img-sizes\n   *\n   * E.g. "(max-width: 30em) 100vw, (max-width: 50em) 70vw, 100vw"\n   * or "(min-width: 30em), calc(30vw - 15px)" or just "30vw"\n   *\n   * Returns the first valid <css-length> with a media condition that evaluates to true,\n   * or "100vw" if all valid media conditions evaluate to false.\n   *\n   */\n\n\n  function parseSizes(strValue) {\n    // (Percentage CSS lengths are not allowed in this case, to avoid confusion:\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#valid-source-size-list\n    // CSS allows a single optional plus or minus sign:\n    // http://www.w3.org/TR/CSS2/syndata.html#numbers\n    // CSS is ASCII case-insensitive:\n    // http://www.w3.org/TR/CSS2/syndata.html#characters )\n    // Spec allows exponential notation for <number> type:\n    // http://dev.w3.org/csswg/css-values/#numbers\n    var regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i; // (This is a quick and lenient test. Because of optional unlimited-depth internal\n    // grouping parens and strict spacing rules, this could get very complicated.)\n\n    var regexCssCalc = /^calc\\((?:[0-9a-z \\.\\+\\-\\*\\/\\(\\)]+)\\)$/i;\n    var i;\n    var unparsedSizesList;\n    var unparsedSizesListLength;\n    var unparsedSize;\n    var lastComponentValue;\n    var size; // UTILITY FUNCTIONS\n    //  (Toy CSS parser. The goals here are:\n    //  1) expansive test coverage without the weight of a full CSS parser.\n    //  2) Avoiding regex wherever convenient.\n    //  Quick tests: http://jsfiddle.net/gtntL4gr/3/\n    //  Returns an array of arrays.)\n\n    function parseComponentValues(str) {\n      var chrctr;\n      var component = "";\n      var componentArray = [];\n      var listArray = [];\n      var parenDepth = 0;\n      var pos = 0;\n      var inComment = false;\n\n      function pushComponent() {\n        if (component) {\n          componentArray.push(component);\n          component = "";\n        }\n      }\n\n      function pushComponentArray() {\n        if (componentArray[0]) {\n          listArray.push(componentArray);\n          componentArray = [];\n        }\n      } // (Loop forwards from the beginning of the string.)\n\n\n      while (true) {\n        chrctr = str.charAt(pos);\n\n        if (chrctr === "") {\n          // ( End of string reached.)\n          pushComponent();\n          pushComponentArray();\n          return listArray;\n        } else if (inComment) {\n          if (chrctr === "*" && str[pos + 1] === "/") {\n            // (At end of a comment.)\n            inComment = false;\n            pos += 2;\n            pushComponent();\n            continue;\n          } else {\n            pos += 1; // (Skip all characters inside comments.)\n\n            continue;\n          }\n        } else if (isSpace(chrctr)) {\n          // (If previous character in loop was also a space, or if\n          // at the beginning of the string, do not add space char to\n          // component.)\n          if (str.charAt(pos - 1) && isSpace(str.charAt(pos - 1)) || !component) {\n            pos += 1;\n            continue;\n          } else if (parenDepth === 0) {\n            pushComponent();\n            pos += 1;\n            continue;\n          } else {\n            // (Replace any space character with a plain space for legibility.)\n            chrctr = " ";\n          }\n        } else if (chrctr === "(") {\n          parenDepth += 1;\n        } else if (chrctr === ")") {\n          parenDepth -= 1;\n        } else if (chrctr === ",") {\n          pushComponent();\n          pushComponentArray();\n          pos += 1;\n          continue;\n        } else if (chrctr === "/" && str.charAt(pos + 1) === "*") {\n          inComment = true;\n          pos += 2;\n          continue;\n        }\n\n        component = component + chrctr;\n        pos += 1;\n      }\n    }\n\n    function isValidNonNegativeSourceSizeValue(s) {\n      if (regexCssLengthWithUnits.test(s) && parseFloat(s) >= 0) {\n        return true;\n      }\n\n      if (regexCssCalc.test(s)) {\n        return true;\n      } // ( http://www.w3.org/TR/CSS2/syndata.html#numbers says:\n      // "-0 is equivalent to 0 and is not a negative number." which means that\n      // unitless zero and unitless negative zero must be accepted as special cases.)\n\n\n      if (s === "0" || s === "-0" || s === "+0") {\n        return true;\n      }\n\n      return false;\n    } // When asked to parse a sizes attribute from an element, parse a\n    // comma-separated list of component values from the value of the element\'s\n    // sizes attribute (or the empty string, if the attribute is absent), and let\n    // unparsed sizes list be the result.\n    // http://dev.w3.org/csswg/css-syntax/#parse-comma-separated-list-of-component-values\n\n\n    unparsedSizesList = parseComponentValues(strValue);\n    unparsedSizesListLength = unparsedSizesList.length; // For each unparsed size in unparsed sizes list:\n\n    for (i = 0; i < unparsedSizesListLength; i++) {\n      unparsedSize = unparsedSizesList[i]; // 1. Remove all consecutive <whitespace-token>s from the end of unparsed size.\n      // ( parseComponentValues() already omits spaces outside of parens. )\n      // If unparsed size is now empty, that is a parse error; continue to the next\n      // iteration of this algorithm.\n      // ( parseComponentValues() won\'t push an empty array. )\n      // 2. If the last component value in unparsed size is a valid non-negative\n      // <source-size-value>, let size be its value and remove the component value\n      // from unparsed size. Any CSS function other than the calc() function is\n      // invalid. Otherwise, there is a parse error; continue to the next iteration\n      // of this algorithm.\n      // http://dev.w3.org/csswg/css-syntax/#parse-component-value\n\n      lastComponentValue = unparsedSize[unparsedSize.length - 1];\n\n      if (isValidNonNegativeSourceSizeValue(lastComponentValue)) {\n        size = lastComponentValue;\n        unparsedSize.pop();\n      } else {\n        continue;\n      } // 3. Remove all consecutive <whitespace-token>s from the end of unparsed\n      // size. If unparsed size is now empty, return size and exit this algorithm.\n      // If this was not the last item in unparsed sizes list, that is a parse error.\n\n\n      if (unparsedSize.length === 0) {\n        return size;\n      } // 4. Parse the remaining component values in unparsed size as a\n      // <media-condition>. If it does not parse correctly, or it does parse\n      // correctly but the <media-condition> evaluates to false, continue to the\n      // next iteration of this algorithm.\n      // (Parsing all possible compound media conditions in JS is heavy, complicated,\n      // and the payoff is unclear. Is there ever an situation where the\n      // media condition parses incorrectly but still somehow evaluates to true?\n      // Can we just rely on the browser/polyfill to do it?)\n\n\n      unparsedSize = unparsedSize.join(" ");\n\n      if (!pf.matchesMedia(unparsedSize)) {\n        continue;\n      } // 5. Return size and exit this algorithm.\n\n\n      return size;\n    } // If the above algorithm exhausts unparsed sizes list without returning a\n    // size value, return 100vw.\n\n\n    return "100vw";\n  } // namespace\n\n\n  pf.ns = ("pf" + new Date().getTime()).substr(0, 9); // srcset support test\n\n  pf.supSrcset = "srcset" in image;\n  pf.supSizes = "sizes" in image;\n  pf.supPicture = !!window.HTMLPictureElement; // UC browser does claim to support srcset and picture, but not sizes,\n  // this extended test reveals the browser does support nothing\n\n  if (pf.supSrcset && pf.supPicture && !pf.supSizes) {\n    (function (image2) {\n      image.srcset = "data:,a";\n      image2.src = "data:,a";\n      pf.supSrcset = image.complete === image2.complete;\n      pf.supPicture = pf.supSrcset && pf.supPicture;\n    })(document.createElement("img"));\n  } // Safari9 has basic support for sizes, but does\'t expose the `sizes` idl attribute\n\n\n  if (pf.supSrcset && !pf.supSizes) {\n    (function () {\n      var width2 = "data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==";\n      var width1 = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n      var img = document.createElement("img");\n\n      var test = function test() {\n        var width = img.width;\n\n        if (width === 2) {\n          pf.supSizes = true;\n        }\n\n        alwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes;\n        isSupportTestReady = true; // force async\n\n        setTimeout(picturefill);\n      };\n\n      img.onload = test;\n      img.onerror = test;\n      img.setAttribute("sizes", "9px");\n      img.srcset = width1 + " 1w," + width2 + " 9w";\n      img.src = width1;\n    })();\n  } else {\n    isSupportTestReady = true;\n  } // using pf.qsa instead of dom traversing does scale much better,\n  // especially on sites mixing responsive and non-responsive images\n\n\n  pf.selShort = "picture>img,img[srcset]";\n  pf.sel = pf.selShort;\n  pf.cfg = cfg;\n  /**\n   * Shortcut property for `devicePixelRatio` ( for easy overriding in tests )\n   */\n\n  pf.DPR = DPR || 1;\n  pf.u = units; // container of supported mime types that one might need to qualify before using\n\n  pf.types = types;\n  pf.setSize = noop;\n  /**\n   * Gets a string and returns the absolute URL\n   * @param src\n   * @returns {String} absolute URL\n   */\n\n  pf.makeUrl = memoize(function (src) {\n    anchor.href = src;\n    return anchor.href;\n  });\n  /**\n   * Gets a DOM element or document and a selctor and returns the found matches\n   * Can be extended with jQuery/Sizzle for IE7 support\n   * @param context\n   * @param sel\n   * @returns {NodeList|Array}\n   */\n\n  pf.qsa = function (context, sel) {\n    return "querySelector" in context ? context.querySelectorAll(sel) : [];\n  };\n  /**\n   * Shortcut method for matchMedia ( for easy overriding in tests )\n   * wether native or pf.mMQ is used will be decided lazy on first call\n   * @returns {boolean}\n   */\n\n\n  pf.matchesMedia = function () {\n    if (window.matchMedia && (matchMedia("(min-width: 0.1em)") || {}).matches) {\n      pf.matchesMedia = function (media) {\n        return !media || matchMedia(media).matches;\n      };\n    } else {\n      pf.matchesMedia = pf.mMQ;\n    }\n\n    return pf.matchesMedia.apply(this, arguments);\n  };\n  /**\n   * A simplified matchMedia implementation for IE8 and IE9\n   * handles only min-width/max-width with px or em values\n   * @param media\n   * @returns {boolean}\n   */\n\n\n  pf.mMQ = function (media) {\n    return media ? evalCSS(media) : true;\n  };\n  /**\n   * Returns the calculated length in css pixel from the given sourceSizeValue\n   * http://dev.w3.org/csswg/css-values-3/#length-value\n   * intended Spec mismatches:\n   * * Does not check for invalid use of CSS functions\n   * * Does handle a computed length of 0 the same as a negative and therefore invalid value\n   * @param sourceSizeValue\n   * @returns {Number}\n   */\n\n\n  pf.calcLength = function (sourceSizeValue) {\n    var value = evalCSS(sourceSizeValue, true) || false;\n\n    if (value < 0) {\n      value = false;\n    }\n\n    return value;\n  };\n  /**\n   * Takes a type string and checks if its supported\n   */\n\n\n  pf.supportsType = function (type) {\n    return type ? types[type] : true;\n  };\n  /**\n   * Parses a sourceSize into mediaCondition (media) and sourceSizeValue (length)\n   * @param sourceSizeStr\n   * @returns {*}\n   */\n\n\n  pf.parseSize = memoize(function (sourceSizeStr) {\n    var match = (sourceSizeStr || "").match(regSize);\n    return {\n      media: match && match[1],\n      length: match && match[2]\n    };\n  });\n\n  pf.parseSet = function (set) {\n    if (!set.cands) {\n      set.cands = parseSrcset(set.srcset, set);\n    }\n\n    return set.cands;\n  };\n  /**\n   * returns 1em in css px for html/body default size\n   * function taken from respondjs\n   * @returns {*|number}\n   */\n\n\n  pf.getEmValue = function () {\n    var body;\n\n    if (!eminpx && (body = document.body)) {\n      var div = document.createElement("div"),\n          originalHTMLCSS = docElem.style.cssText,\n          originalBodyCSS = body.style.cssText;\n      div.style.cssText = baseStyle; // 1em in a media query is the value of the default font size of the browser\n      // reset docElem and body to ensure the correct value is returned\n\n      docElem.style.cssText = fsCss;\n      body.style.cssText = fsCss;\n      body.appendChild(div);\n      eminpx = div.offsetWidth;\n      body.removeChild(div); //also update eminpx before returning\n\n      eminpx = parseFloat(eminpx, 10); // restore the original values\n\n      docElem.style.cssText = originalHTMLCSS;\n      body.style.cssText = originalBodyCSS;\n    }\n\n    return eminpx || 16;\n  };\n  /**\n   * Takes a string of sizes and returns the width in pixels as a number\n   */\n\n\n  pf.calcListLength = function (sourceSizeListStr) {\n    // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%\n    //\n    //                           or (min-width:30em) calc(30% - 15px)\n    if (!(sourceSizeListStr in sizeLengthCache) || cfg.uT) {\n      var winningLength = pf.calcLength(parseSizes(sourceSizeListStr));\n      sizeLengthCache[sourceSizeListStr] = !winningLength ? units.width : winningLength;\n    }\n\n    return sizeLengthCache[sourceSizeListStr];\n  };\n  /**\n   * Takes a candidate object with a srcset property in the form of url/\n   * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or\n   *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or\n   *     "images/pic-small.png"\n   * Get an array of image candidates in the form of\n   *      {url: "/foo/bar.png", resolution: 1}\n   * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value\n   * If sizes is specified, res is calculated\n   */\n\n\n  pf.setRes = function (set) {\n    var candidates;\n\n    if (set) {\n      candidates = pf.parseSet(set);\n\n      for (var i = 0, len = candidates.length; i < len; i++) {\n        setResolution(candidates[i], set.sizes);\n      }\n    }\n\n    return candidates;\n  };\n\n  pf.setRes.res = setResolution;\n\n  pf.applySetCandidate = function (candidates, img) {\n    if (!candidates.length) {\n      return;\n    }\n\n    var candidate, i, j, length, bestCandidate, curSrc, curCan, candidateSrc, abortCurSrc;\n    var imageData = img[pf.ns];\n    var dpr = pf.DPR;\n    curSrc = imageData.curSrc || img[curSrcProp];\n    curCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set); // if we have a current source, we might either become lazy or give this source some advantage\n\n    if (curCan && curCan.set === candidates[0].set) {\n      // if browser can abort image request and the image has a higher pixel density than needed\n      // and this image isn\'t downloaded yet, we skip next part and try to save bandwidth\n      abortCurSrc = supportAbort && !img.complete && curCan.res - 0.1 > dpr;\n\n      if (!abortCurSrc) {\n        curCan.cached = true; // if current candidate is "best", "better" or "okay",\n        // set it to bestCandidate\n\n        if (curCan.res >= dpr) {\n          bestCandidate = curCan;\n        }\n      }\n    }\n\n    if (!bestCandidate) {\n      candidates.sort(ascendingSort);\n      length = candidates.length;\n      bestCandidate = candidates[length - 1];\n\n      for (i = 0; i < length; i++) {\n        candidate = candidates[i];\n\n        if (candidate.res >= dpr) {\n          j = i - 1; // we have found the perfect candidate,\n          // but let\'s improve this a little bit with some assumptions ;-)\n\n          if (candidates[j] && (abortCurSrc || curSrc !== pf.makeUrl(candidate.url)) && chooseLowRes(candidates[j].res, candidate.res, dpr, candidates[j].cached)) {\n            bestCandidate = candidates[j];\n          } else {\n            bestCandidate = candidate;\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (bestCandidate) {\n      candidateSrc = pf.makeUrl(bestCandidate.url);\n      imageData.curSrc = candidateSrc;\n      imageData.curCan = bestCandidate;\n\n      if (candidateSrc !== curSrc) {\n        pf.setSrc(img, bestCandidate);\n      }\n\n      pf.setSize(img);\n    }\n  };\n\n  pf.setSrc = function (img, bestCandidate) {\n    var origWidth;\n    img.src = bestCandidate.url; // although this is a specific Safari issue, we don\'t want to take too much different code paths\n\n    if (bestCandidate.set.type === "image/svg+xml") {\n      origWidth = img.style.width;\n      img.style.width = img.offsetWidth + 1 + "px"; // next line only should trigger a repaint\n      // if... is only done to trick dead code removal\n\n      if (img.offsetWidth + 1) {\n        img.style.width = origWidth;\n      }\n    }\n  };\n\n  pf.getSet = function (img) {\n    var i, set, supportsType;\n    var match = false;\n    var sets = img[pf.ns].sets;\n\n    for (i = 0; i < sets.length && !match; i++) {\n      set = sets[i];\n\n      if (!set.srcset || !pf.matchesMedia(set.media) || !(supportsType = pf.supportsType(set.type))) {\n        continue;\n      }\n\n      if (supportsType === "pending") {\n        set = supportsType;\n      }\n\n      match = set;\n      break;\n    }\n\n    return match;\n  };\n\n  pf.parseSets = function (element, parent, options) {\n    var srcsetAttribute, imageSet, isWDescripor, srcsetParsed;\n    var hasPicture = parent && parent.nodeName.toUpperCase() === "PICTURE";\n    var imageData = element[pf.ns];\n\n    if (imageData.src === undefined || options.src) {\n      imageData.src = getImgAttr.call(element, "src");\n\n      if (imageData.src) {\n        setImgAttr.call(element, srcAttr, imageData.src);\n      } else {\n        removeImgAttr.call(element, srcAttr);\n      }\n    }\n\n    if (imageData.srcset === undefined || options.srcset || !pf.supSrcset || element.srcset) {\n      srcsetAttribute = getImgAttr.call(element, "srcset");\n      imageData.srcset = srcsetAttribute;\n      srcsetParsed = true;\n    }\n\n    imageData.sets = [];\n\n    if (hasPicture) {\n      imageData.pic = true;\n      getAllSourceElements(parent, imageData.sets);\n    }\n\n    if (imageData.srcset) {\n      imageSet = {\n        srcset: imageData.srcset,\n        sizes: getImgAttr.call(element, "sizes")\n      };\n      imageData.sets.push(imageSet);\n      isWDescripor = (alwaysCheckWDescriptor || imageData.src) && regWDesc.test(imageData.srcset || ""); // add normal src as candidate, if source has no w descriptor\n\n      if (!isWDescripor && imageData.src && !getCandidateForSrc(imageData.src, imageSet) && !imageSet.has1x) {\n        imageSet.srcset += ", " + imageData.src;\n        imageSet.cands.push({\n          url: imageData.src,\n          d: 1,\n          set: imageSet\n        });\n      }\n    } else if (imageData.src) {\n      imageData.sets.push({\n        srcset: imageData.src,\n        sizes: null\n      });\n    }\n\n    imageData.curCan = null;\n    imageData.curSrc = undefined; // if img has picture or the srcset was removed or has a srcset and does not support srcset at all\n    // or has a w descriptor (and does not support sizes) set support to false to evaluate\n\n    imageData.supported = !(hasPicture || imageSet && !pf.supSrcset || isWDescripor && !pf.supSizes);\n\n    if (srcsetParsed && pf.supSrcset && !imageData.supported) {\n      if (srcsetAttribute) {\n        setImgAttr.call(element, srcsetAttr, srcsetAttribute);\n        element.srcset = "";\n      } else {\n        removeImgAttr.call(element, srcsetAttr);\n      }\n    }\n\n    if (imageData.supported && !imageData.srcset && (!imageData.src && element.src || element.src !== pf.makeUrl(imageData.src))) {\n      if (imageData.src === null) {\n        element.removeAttribute("src");\n      } else {\n        element.src = imageData.src;\n      }\n    }\n\n    imageData.parsed = true;\n  };\n\n  pf.fillImg = function (element, options) {\n    var imageData;\n    var extreme = options.reselect || options.reevaluate; // expando for caching data on the img\n\n    if (!element[pf.ns]) {\n      element[pf.ns] = {};\n    }\n\n    imageData = element[pf.ns]; // if the element has already been evaluated, skip it\n    // unless `options.reevaluate` is set to true ( this, for example,\n    // is set to true when running `picturefill` on `resize` ).\n\n    if (!extreme && imageData.evaled === evalId) {\n      return;\n    }\n\n    if (!imageData.parsed || options.reevaluate) {\n      pf.parseSets(element, element.parentNode, options);\n    }\n\n    if (!imageData.supported) {\n      applyBestCandidate(element);\n    } else {\n      imageData.evaled = evalId;\n    }\n  };\n\n  pf.setupRun = function () {\n    if (!alreadyRun || isVwDirty || DPR !== window.devicePixelRatio) {\n      updateMetrics();\n    }\n  }; // If picture is supported, well, that\'s awesome.\n\n\n  if (pf.supPicture) {\n    picturefill = noop;\n    pf.fillImg = noop;\n  } else {\n    // Set up picture polyfill by polling the document\n    (function () {\n      var isDomReady;\n      var regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/;\n\n      var run = function run() {\n        var readyState = document.readyState || "";\n        timerId = setTimeout(run, readyState === "loading" ? 200 : 999);\n\n        if (document.body) {\n          pf.fillImgs();\n          isDomReady = isDomReady || regReady.test(readyState);\n\n          if (isDomReady) {\n            clearTimeout(timerId);\n          }\n        }\n      };\n\n      var timerId = setTimeout(run, document.body ? 9 : 99); // Also attach picturefill on resize and readystatechange\n      // http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html\n\n      var debounce = function debounce(func, wait) {\n        var timeout, timestamp;\n\n        var later = function later() {\n          var last = new Date() - timestamp;\n\n          if (last < wait) {\n            timeout = setTimeout(later, wait - last);\n          } else {\n            timeout = null;\n            func();\n          }\n        };\n\n        return function () {\n          timestamp = new Date();\n\n          if (!timeout) {\n            timeout = setTimeout(later, wait);\n          }\n        };\n      };\n\n      var lastClientWidth = docElem.clientHeight;\n\n      var onResize = function onResize() {\n        isVwDirty = Math.max(window.innerWidth || 0, docElem.clientWidth) !== units.width || docElem.clientHeight !== lastClientWidth;\n        lastClientWidth = docElem.clientHeight;\n\n        if (isVwDirty) {\n          pf.fillImgs();\n        }\n      };\n\n      on(window, "resize", debounce(onResize, 99));\n      on(document, "readystatechange", run);\n    })();\n  }\n\n  pf.picturefill = picturefill; //use this internally for easy monkey patching/performance testing\n\n  pf.fillImgs = picturefill;\n  pf.teardownRun = noop;\n  /* expose methods for testing */\n\n  picturefill._ = pf;\n  window.picturefillCFG = {\n    pf: pf,\n    push: function push(args) {\n      var name = args.shift();\n\n      if (typeof pf[name] === "function") {\n        pf[name].apply(pf, args);\n      } else {\n        cfg[name] = args[0];\n\n        if (alreadyRun) {\n          pf.fillImgs({\n            reselect: true\n          });\n        }\n      }\n    }\n  };\n\n  while (setOptions && setOptions.length) {\n    window.picturefillCFG.push(setOptions.shift());\n  }\n  /* expose picturefill */\n\n\n  window.picturefill = picturefill;\n  /* expose picturefill */\n\n  if (( false ? undefined : _typeof(module)) === "object" && _typeof(module.exports) === "object") {\n    // CommonJS, just export\n    module.exports = picturefill;\n  } else if (true) {\n    // AMD support\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return picturefill;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } // IE8 evals this sync, so it must be the last thing we do\n\n\n  if (!pf.supPicture) {\n    types["image/webp"] = detectTypeSupport("image/webp", "data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==");\n  }\n})(window, document);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(85)(module)))\n\n//# sourceURL=webpack:///./node_modules/picturefill/dist/picturefill.js?')},376:function(module,exports,__webpack_require__){eval("__webpack_require__(377);\n__webpack_require__(378);\n__webpack_require__(379);\nmodule.exports = __webpack_require__(204);\n\n\n//# sourceURL=webpack:///multi_lodash.throttle_lodash.debounce_dompurify_picturefill?")},377:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/** Used as references for various `Number` constants. */\n\nvar NAN = 0 / 0;\n/** `Object#toString` result references. */\n\nvar symbolTag = '[object Symbol]';\n/** Used to match leading and trailing whitespace. */\n\nvar reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */\n\nvar reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */\n\nvar reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */\n\nvar freeParseInt = parseInt;\n/** Detect free variable `global` from Node.js. */\n\nvar freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\n/** Detect free variable `self`. */\n\nvar freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\n\nvar now = function now() {\n  return root.Date.now();\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\n\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\n\n\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return !!value && (type == 'object' || type == 'function');\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return !!value && _typeof(value) == 'object';\n}\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\n\nfunction isSymbol(value) {\n  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\n\n\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? other + '' : other;\n  }\n\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nmodule.exports = throttle;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(61)))\n\n//# sourceURL=webpack:///./node_modules/lodash.throttle/index.js?")},378:function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n/** Used as references for various `Number` constants. */\n\nvar NAN = 0 / 0;\n/** `Object#toString` result references. */\n\nvar symbolTag = '[object Symbol]';\n/** Used to match leading and trailing whitespace. */\n\nvar reTrim = /^\\s+|\\s+$/g;\n/** Used to detect bad signed hexadecimal string values. */\n\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n/** Used to detect binary string values. */\n\nvar reIsBinary = /^0b[01]+$/i;\n/** Used to detect octal string values. */\n\nvar reIsOctal = /^0o[0-7]+$/i;\n/** Built-in method references without a dependency on `root`. */\n\nvar freeParseInt = parseInt;\n/** Detect free variable `global` from Node.js. */\n\nvar freeGlobal = (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) == 'object' && global && global.Object === Object && global;\n/** Detect free variable `self`. */\n\nvar freeSelf = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) == 'object' && self && self.Object === Object && self;\n/** Used as a reference to the global object. */\n\nvar root = freeGlobal || freeSelf || Function('return this')();\n/** Used for built-in method references. */\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\n\nvar now = function now() {\n  return root.Date.now();\n};\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\n\n\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n\n  wait = toNumber(wait) || 0;\n\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    var time = now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\n\n\nfunction isObject(value) {\n  var type = _typeof(value);\n\n  return !!value && (type == 'object' || type == 'function');\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\n\n\nfunction isObjectLike(value) {\n  return !!value && _typeof(value) == 'object';\n}\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\n\n\nfunction isSymbol(value) {\n  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n}\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\n\n\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n\n  if (isSymbol(value)) {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? other + '' : other;\n  }\n\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n}\n\nmodule.exports = debounce;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(61)))\n\n//# sourceURL=webpack:///./node_modules/lodash.debounce/index.js?")},379:function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */\n(function (global, factory) {\n  ( false ? undefined : _typeof2(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(this, function () {\n  'use strict';\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n  var regExpTest = unapply(RegExp.prototype.test);\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n  /* Add properties to a lookup table */\n\n\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n\n    while (l--) {\n      var element = array[l];\n\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n  /* Shallow clone an object */\n\n\n  function clone(object) {\n    var newObject = create(null);\n    var property = void 0;\n\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n\n\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG\n\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  var text = freeze(['#text']);\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']); // eslint-disable-next-line unicorn/better-regex\n\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return _typeof2(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n  };\n\n  function _toConsumableArray$1(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n\n\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    } // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n\n\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n\n\n    DOMPurify.version = '2.2.9';\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n    var ElementPrototype = Element.prototype;\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        createDocumentFragment = _document.createDocumentFragment;\n    var importNode = originalDocument.importNode;\n    var documentMode = {};\n\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n\n    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n    /* Allowed attribute names */\n\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n\n    var FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n\n    var FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */\n\n    var ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */\n\n    var ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */\n\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n\n    var SAFE_FOR_TEMPLATES = false;\n    /* Decide if document with <html>... should be returned */\n\n    var WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */\n\n    var SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n\n    var FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n\n    var RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n\n    var RETURN_DOM_FRAGMENT = false;\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n\n    var RETURN_DOM_IMPORT = true;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n\n    var RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks? */\n\n    var SANITIZE_DOM = true;\n    /* Keep element content when removing element? */\n\n    var KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n\n    var IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */\n\n    var USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n\n    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    /* Tags that are safe for data: URIs */\n\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    /* Attributes safe for values like \"javascript:\" */\n\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n    /* Keep a reference to config to pass to hooks */\n\n    var CONFIG = null;\n    /* Ideally, do not touch anything below this line */\n\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n      /* Shield configuration object from tampering */\n\n\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n      /* Shield configuration object from prototype pollution */\n\n\n      cfg = clone(cfg);\n      /* Set configuration parameters */\n\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n      /* Parse profile info */\n\n\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n      /* Merge configuration parameters */\n\n\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n      /* Add #text in case KEEP_CONTENT is set to true */\n\n\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n\n\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n\n\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      } // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n\n\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        } // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n\n\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        } // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n\n\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        } // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n\n\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        } // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n\n\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        } // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n\n\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']); // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      } // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n\n\n      return false;\n    };\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n\n\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n\n\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name); // We void attribute values for unremovable \"is\"\" attributes\n\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n\n\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n        } catch (_) {}\n      }\n      /* Use createHTMLDocument in case DOMParser is not available */\n\n\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n        } catch (_) {// Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      var body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n      /* Work on whole document or just its body */\n\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n\n\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n\n\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n\n\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n\n\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n\n\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeElements', currentNode, null);\n      /* Check if element is clobbered or can clobber */\n\n\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Check if tagname contains Unicode */\n\n\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Now let's check the element's type and name */\n\n\n      var tagName = stringToLowerCase(currentNode.nodeName);\n      /* Execute a hook if present */\n\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n      /* Detect mXSS attempts abusing namespace confusion */\n\n\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Remove element if anything forbids its presence */\n\n\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            var childCount = childNodes.length;\n\n            for (var i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Check whether element has a valid namespace */\n\n\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n      /* Sanitize element content to be template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n\n\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n\n\n      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ;else if (!value) ;else {\n        return false;\n      }\n      return true;\n    };\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n\n\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n      /* Go backwards over all attributes; safely remove bad ones */\n\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n        value = stringTrim(attr.value);\n        lcName = stringToLowerCase(name);\n        /* Execute a hook if present */\n\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n        /* Remove attribute */\n\n\n        _removeAttribute(name, currentNode);\n        /* Did the hooks approve of the attribute? */\n\n\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n        /* Work around a security issue in jQuery 3.0 */\n\n\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n        /* Sanitize attribute content to be template-safe */\n\n\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n        /* Is `value` valid for this attribute? */\n\n\n        var lcTag = currentNode.nodeName.toLowerCase();\n\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n        /* Handle invalid data-* attribute set by try-catching it */\n\n\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n\n\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n\n      var shadowIterator = _createIterator(fragment);\n      /* Execute a hook if present */\n\n\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n        /* Sanitize tags and elements */\n\n\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n        /* Deep shadow DOM detected */\n\n\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(shadowNode);\n      }\n      /* Execute a hook if present */\n\n\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n\n\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n\n      IS_EMPTY_INPUT = !dirty;\n\n      if (IS_EMPTY_INPUT) {\n        dirty = '\x3c!--\x3e';\n      }\n      /* Stringify, in case dirty is an object */\n\n\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n      /* Check we can run. Otherwise fall back or ignore */\n\n\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n      /* Assign config vars */\n\n\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n      /* Clean up removed elements */\n\n\n      DOMPurify.removed = [];\n      /* Check if dirty is correctly typed for IN_PLACE */\n\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ;else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('\x3c!----\x3e');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n        /* Initialize the document to work on */\n\n\n        body = _initDocument(dirty);\n        /* Check we have a DOM node from the data */\n\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n      /* Remove first element node (ours) if FORCE_BODY is set */\n\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n      /* Get node iterator */\n\n\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n      /* Now start iterating over the created document */\n\n\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n        /* Sanitize tags and elements */\n\n\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n        /* Shadow DOM detected, sanitize it */\n\n\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n        /* Check attributes, sanitize if necessary */\n\n\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n      /* If we sanitized `dirty` in-place, return it. */\n\n      if (IN_PLACE) {\n        return dirty;\n      }\n      /* Return sanitized string or DOM */\n\n\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n      /* Sanitize final string template-safe */\n\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n\n\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n\n      SET_CONFIG = true;\n    };\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n\n\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n\n\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = stringToLowerCase(tag);\n      var lcName = stringToLowerCase(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n\n\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n\n\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n\n\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n\n\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n  return purify;\n});\n\n//# sourceURL=webpack:///./node_modules/dompurify/dist/purify.js?")},61:function(module,exports){eval('function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nvar g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function("return this")();\n} catch (e) {\n  // This works if the window reference is available\n  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},85:function(module,exports){eval('module.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = []; // module.parent = undefined by default\n\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, "loaded", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, "id", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?')}});